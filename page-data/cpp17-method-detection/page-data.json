{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/cpp17-method-detection/","result":{"data":{"site":{"siteMetadata":{"title":"Be Best Dev","social":[{"name":"github","url":"https://github.com/artsiukhou"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"eb6cadee-c4d5-5cb2-8da6-ae070d494c01","excerpt":"You know that feeling when you've just read about some feature or tool and then you're looking for a chance to use it?\nI always wanted toâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Refactoring with Modern(-ish) C++: Method Detection\",\n  \"date\": \"2021-04-10T00:00:00.000Z\",\n  \"tags\": [\"C++\", \"refactoring\", \"templates\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"You know that feeling when you\\u2019ve just read about some feature or tool and then you\\u2019re looking for a chance to use it?\\nI always wanted to try out some \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Modern C++\"), \" meta-template-magic items, and finally, I found a real use case for some\\nof them in one of the projects I\\u2019m working on. Well, sometimes one waits for too long, so worth saying that everything below\\nis suitable for C++17 (which I do consider \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Modern C++\"), \"), but in C++20 there are easier ways of achieving the same result.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"All the code from this post can be found on \", mdx(\"a\", _extends({\n    parentName: \"em\"\n  }, {\n    \"href\": \"https://github.com/artsiukhou/blog_examples/tree/main/cpp-method-detection\"\n  }), \"GitHub\"), \".\")), mdx(\"p\", null, \"I\\u2019m refactoring a code in a file that is an entry point to our service.\\nIt contains a lot (really, more than 80) autogenerated signatures of methods that are processing different requests\\nand there are plenty of common items that are copy-pasted between these methods.\\nFor example, each response type has \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".status()\"), \" method to access field of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Status\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"class Status {\\npublic:\\n    string& result() { return _result; }\\n    string& message() { return _message; }\\nprivate:\\n    string _result;\\n    string _message;\\n};\\n\\nclass AnyResponse {\\npublic:\\n    Status& status() { return _status; }\\nprivate:\\n    Status _status;\\n};\\n\")), mdx(\"p\", null, \"So every request processing function looks like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"RespA entrypointToRequestA(const ReqA& reqA) {\\n    RespA respA;\\n    respA.status().result() = \\\"SUCCESS\\\";\\n    respA.status().message() = \\\"SUCCESS\\\";\\n    try {\\n        processReqA(reqA, respA);\\n    } catch (const std::exception& ex) {\\n        respA.status().result() = \\\"FAIL\\\";\\n        respA.status().message() = ex.what();\\n    }\\n    return respA;\\n}\\n\")), mdx(\"p\", null, \"I want \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"any\"), \" method to be as simple as:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"AnyResp entrypointToAnyRequest(const AnyReq& anyReq) {\\n    return genericProcessor<AnyReq, AnyResp>(anyReq, processAnyReq);\\n}\\n\")), mdx(\"p\", null, \"where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"genericProcessor<ReqType, RespType>()\"), \" is the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename Req, typename Resp, typename Processor>\\nResp genericProcessor(const Req& req, Processor&& processorFunc) {\\n    Resp resp;\\n    resp.status().result() = \\\"SUCCESS\\\";\\n    resp.status().message() = \\\"SUCCESS\\\";\\n    try {\\n        processorFunc(req, resp);\\n    } catch (const std::exception& ex) {\\n        resp.status().result() = \\\"FAIL\\\";\\n        resp.status().message() = ex.what();\\n    }\\n    return resp;\\n}\\n\")), mdx(\"p\", null, \"Why? Well, it\\u2019s 1 line of code instead of 10 (and we have 80 more places like this, remember? reduce \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Software_entropy\"\n  }), \"code entropy\"), \"!).\\nIf it\\u2019s not enough: I can also modify just 1 method instead of 80 when I want to add, for example, some logs for each of the incoming requests;\\nor put something different to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".result()\"), \" on different exception types; or collect common for each request metrics like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"processingTime\"), \". And so on, and so on.\"), mdx(\"p\", null, \"But that\\u2019s simple, the code from above is already doing it! Uh, ok, I lied. For the reason unknown, some of the responses are just of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Status\"), \".\\n\\u201CHistorical reasons\\u201D, you know. So code there is:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"Status entrypointToRequestB(const ReqB& reqB) {\\n    Status status;\\n    status.result() = \\\"SUCCESS\\\";\\n    status.message() = \\\"SUCCESS\\\";\\n    try {\\n        processReqB(reqB, status);\\n    } catch (const std::exception& ex) {\\n        status.result() = \\\"FAIL\\\";\\n        status.message() = ex.what();\\n    }\\n    return status;\\n}\\n\")), mdx(\"p\", null, \"Ok, easy-peasy, let\\u2019s introduce the following \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setStatus()\"), \" function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"void setStatus(Status& status, const string_view result, const string_view message) {\\n    status.result() = result;\\n    status.message() = message;\\n}\\n\")), mdx(\"p\", null, \"And a templated version of it for any other type, which will even reuse the non-templated:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename T>\\nvoid setStatus(T& resp, const string_view result, const string_view message) {\\n    setStatus(resp.status(), result, message);\\n}\\n\")), mdx(\"p\", null, \"Thanks to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.cppreference.com/w/cpp/language/overload_resolution\"\n  }), \"function overloading\"), \", this will work! So our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"genericProcessor()\"), \" now looks like:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename Req, typename Resp, typename Processor>\\nResp genericProcessor(const Req& req, Processor&& processorFunc) {\\n    Resp resp;\\n    setStatus(resp, \\\"SUCCESS\\\", \\\"SUCCESS\\\");\\n    try {\\n        processorFunc(req, resp);\\n    } catch (const std::exception& ex) {\\n        setStatus(resp, \\\"FAIL\\\", ex.what());\\n    }\\n    return resp;\\n}\\n\")), mdx(\"p\", null, \"Nice! git add, git commit, git push! Wait\\u2026 Ok, that\\u2019s not all.\\nFor another set of historical reasons some of the responses don\\u2019t have anything like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".status()\"), \" method at all, they are just responses:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"RespC entrypointToRequestC(const ReqC& reqC) {\\n    RespC respC;\\n    processReqC(reqC, respC);\\n    return respC;\\n}\\n\")), mdx(\"p\", null, \"So, we can\\u2019t use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"genericProcessor()\"), \" as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RespC\"), \" class doesn\\u2019t have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".status()\"), \" method required in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setStatus()\"), \" helper.\\nBut we still want to call it! We want all of our requests to be welcomed equally, have logs and metrics we will define in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"genericProcessor()\"), \".\\nSo, what if we will teach templated \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setStatus()\"), \" to know if the type has \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".status()\"), \" method, and if it\\u2019s not then it will be no-op?\\nHere \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Modern C++\"), \" comes in handy!\"), mdx(\"p\", null, \"How can we do this? To be honest, I don\\u2019t want to go too deep into details and rewrite many good StackOverflow responses and articles from the web because\\nI\\u2019m a) lazy b) lazy (choose your option). I\\u2019ll be focusing on the big picture and will provide links where you can learn more about how \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"exactly\"), \" this works.\"), mdx(\"p\", null, \"To start with, we\\u2019re implementing a helper struct that helps us to detect if some type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T\"), \" has \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".status()\"), \" method\\n(thanks, \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://stackoverflow.com/questions/257288/templated-check-for-the-existence-of-a-class-member-function\"\n  }), \"StackOverflow\"), \").\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename T, typename = std::void_t<>>\\nstruct hasStatus: std::false_type {\\n};\\n\\ntemplate <typename T>\\nstruct hasStatus<T, std::void_t<decltype(&T::status)>>: std::true_type {\\n};\\n\")), mdx(\"p\", null, \"The first struct is a templated struct to which any type will be resolved to and it indicates \\u201Cno-status\\u201D types.\\nThe second struct is a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.cppreference.com/w/cpp/language/partial_specialization\"\n  }), \"partial specialization\"), \" of the first struct for types that have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T::status\"), \" method.\\nThe main feature here is that if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T\"), \" doesn\\u2019t have this method, it\\u2019s not an error, thanks to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.cppreference.com/w/cpp/language/sfinae\"\n  }), \"SFINAE\"), \"!\\nBoth \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::false_type\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::true_type\"), \" structs provide a field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"constexpr static bool value\"), \" by which we can test the type.\"), mdx(\"p\", null, \"Ok, so now we can modify our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".setStatus()\"), \"!\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename T>\\nvoid setStatus(T& resp, const string_view code, const string_view message) {\\n    if constexpr (hasStatus<T>::value) {\\n        setStatus(resp.status(), code, message);\\n    } else {\\n        /* no-op */\\n    }\\n}\\n\")), mdx(\"p\", null, \"It compiles, it works on simple structures I\\u2019m using for tests.\\nWith a great sense of joy, I copy-pasted our helpers to a real codebase\\u2026 Added some tests\\u2026 Ran them\\u2026 And they\\u2026 FAILED.\"), mdx(\"p\", null, \"What? How? Why? But it works on tests structs!? And there is no compile error, no warnings, it just produces not the result I want.\\nWell, requests with just \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Status\"), \" as response work well. At least something. Requests with no \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".status()\"), \" method in response work as well.\\n2 out of 3 already. So the issue is only with requests that have responses with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".status()\"), \".\\nLooking closer at the real responses and comparing them to the test structs I noticed that each response with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".status()\"), \" method actually has 2 such methods:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"class RealResponse {\\npublic:\\n    Status& status() { return _status; }\\n    const Status& status() const { return _status; }\\nprivate:\\n    Status _status;\\n};\\n\")), mdx(\"p\", null, \"Ok, adding the const method to our test struct. And indeed, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasStatus\"), \" doesn\\u2019t work any more! But why?\\nLet\\u2019s have a closer look at the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hasStatus\"), \" definition:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename T>\\nstruct hasStatus<T, std::void_t<decltype(&T::status)>>: std::true_type {};\\n\")), mdx(\"p\", null, \"It takes a return type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"&T::status\"), \". If there is no \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".status()\"), \" it just skips this definition because of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"SFINAE\"), \".\\nBut if there are 2 different \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".status()\"), \" methods it \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"doesn\\u2019t know\"), \" which type to take, so it skips it as well!\\nSo for any type with 2 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".status()\"), \" methods, this will never work! How this can be fixed?\\nInstead of checking the method existence on a type, we can instead invoke it on an object of this type by doing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T().status()\"), \", or better \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::declval<T>().status()\"), \"!\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename T>\\nstruct hasStatus<T, std::void_t<decltype(std::declval<T>()::status())>>: std::true_type {};\\n\")), mdx(\"p\", null, \"Note that no real invocation happening here, this construction is kind of saying\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\u201Cimagine that we have an object of type \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"T\"), \" and we invoke \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \".status()\"), \" and we get the resulting type\\u201D\"), \".\\nAnd we don\\u2019t care about the resulting type itself, with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"void_t<>\"), \" it will be voided anyway.\\nWhat we care about is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"the whole construction\"), \" to be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"valid\"), \", so the specialization will be selected.\"), mdx(\"p\", null, \"That\\u2019s all, folks!\"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/cpp17-method-detection/","title":"Refactoring with Modern(-ish) C++: Method Detection","tags":["C++","refactoring","templates"],"keywords":[],"date":"April 10, 2021","image":null,"imageAlt":null,"socialImage":null},"previous":{"__typename":"MdxBlogPost","id":"7ad532e0-fb5b-52e1-8cdf-4be776f4cc44","excerpt":"How often do you catch yourself on a thought:  \"Ok, I should have a blog!\" ?\nWell, it happens to me all the times. And you know what? I'mâ€¦","slug":"/hello-world/","title":"Hello, World!","date":"April 05, 2021"},"next":{"__typename":"MdxBlogPost","id":"829f6294-9932-585c-be65-99b574303910","excerpt":"Today I want to share some quite random thoughts about  complexity  and why it matters (or not?) with a real-life example I've faced at oneâ€¦","slug":"/complexity-matters/","title":"Complexity Matters?","date":"May 06, 2021"}},"pageContext":{"id":"eb6cadee-c4d5-5cb2-8da6-ae070d494c01","previousId":"7ad532e0-fb5b-52e1-8cdf-4be776f4cc44","nextId":"829f6294-9932-585c-be65-99b574303910"}},"staticQueryHashes":["416447326","4198970465","764694655"]}