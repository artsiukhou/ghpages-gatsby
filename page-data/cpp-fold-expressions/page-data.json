{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/cpp-fold-expressions/","result":{"data":{"site":{"siteMetadata":{"title":"Be Best Dev","social":[{"name":"github","url":"https://github.com/artsiukhou"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"bfc4e3ab-a9f1-52e5-86de-a535f72053d8","excerpt":"Let's write a function that helps us to print debug our code. The function takes another function and its set of parameters as argumentsâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Modern C++: Variadic Templates and Fold Expressions\",\n  \"date\": \"2021-05-12T00:00:00.000Z\",\n  \"tags\": [\"C++\", \"templates\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Let\\u2019s write a function that helps us to print debug our code. The function takes another function and its set of parameters as arguments, prints all the arguments and invokes the passed function.\"), mdx(\"p\", null, \"In Python, it would be as simple as (let\\u2019s forget for a second about decorators, kwargs and so on):\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"def debugger(func, *args):\\n    print(*args)\\n    func(args)\\n\")), mdx(\"p\", null, \"But how are you going to do this in C++?\"), mdx(\"p\", null, \"Luckily, we\\u2019ve got \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.cppreference.com/w/cpp/language/parameter_pack\"\n  }), \"variadic templates\"), \" with the C++11 standard. I have used it multiple times (though still googling where to put this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"...\"), \"), so I know that it\\u2019s relatively easy to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"proxy\"), \" arguments (assuming we have all the includes and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"using\"), \"s:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"void func1(int x) {\\n    cout << \\\"invoked func1(int): \\\" << x << endl;\\n}\\n\\nvoid func2(int x, int y) {\\n    cout << \\\"invoked func2(int, int): \\\" << x << \\\" \\\" << y << endl;\\n}\\n\\nvoid func3(double x, int y) {\\n    cout << \\\"invoked func3(double, int): \\\" << x << \\\" \\\" << y << endl;\\n}\\n\\nvoid func4() {\\n    cout << \\\"invoked func4()\\\" << endl;\\n}\\n\\ntemplate <typename Func, typename ...Args>\\nvoid debugger(Func&& f, Args&&... args) {\\n    f(forward<Args>(args)...);\\n}\\n\\nint main()\\n{\\n    debugger(func1, 1);\\n    // printed: \\\"invoked func1(int): 1\\\"\\n    debugger(func2, 1, 2);\\n    // printed: \\\"invoked func2(int, int): 1 2\\\"\\n    debugger(func3, 1.4, 2);\\n    // printed: \\\"invoked func3(double, int): 1.4 2\\\"\\n    debugger(func4);\\n    // printed: \\\"invoked func4()\\\"\\n    return 0;\\n}\\n\")), mdx(\"p\", null, \"Ok, but how to print the arguments?\"), mdx(\"p\", null, \"The same webpage about variadic templates actually provides an example with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"brace-enclosed initializers\"), \", so our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"debugger\"), \" can look like this\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \":\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename Func, typename ...Args>\\nvoid debugger(Func&& f, Args&&... args) {\\n    int dummy[sizeof...(Args)] = { (cout << args << \\\" \\\", 0)... };\\n    if (sizeof...(Args) != 0) {\\n        cout << endl;\\n    }\\n    f(forward<Args>(args)...);\\n}\\n\")), mdx(\"p\", null, \"IMO that\\u2019s not a very nice code \\u2014 it\\u2019s quite difficult to read and understand such code, also we create some array just to imitate iteration through the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"args\"), \".\"), mdx(\"p\", null, \"Okay then, there is another way. We will add another helper function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"printer\"), \" that prints the first argument and then invokes itself with the rest of the arguments. But to make it work we also need to have a \\u201Ctermination\\u201D state, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"printer\"), \" with no parameters:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"void printer() {\\n    cout << endl;\\n}\\n\\ntemplate <typename Head, typename ...Tail>\\nvoid printer(Head&& h, Tail&&... tail) {\\n    cout << h << \\\" \\\";\\n    printer(tail...);\\n}\\n\")), mdx(\"p\", null, \"So, our updated \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"debugger2\"), \" function has the following form now:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename Func, typename ...Args>\\nvoid debugger_w_printer(Func&& f, Args&&... args) {\\n    if (sizeof...(Args) != 0) {\\n        printer(args...);\\n    }\\n    f(forward<Args>(args)...);\\n}\\n\")), mdx(\"p\", null, \"That\\u2019s all good for the C++11/14. But maybe things are better in the C++17? Well, they are better indeed! To start with, there is \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.cppreference.com/w/cpp/language/if\"\n  }), \"constexpr if\"), \" statement, so we can combine both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"printer\"), \" functions together:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename Head, typename ...Tail>\\nvoid printer17(Head&& h, Tail&&... tail) {\\n    cout << h << \\\" \\\";\\n    if constexpr (sizeof...(Tail) != 0) {\\n        printer17(tail...);\\n    } else {\\n        cout << endl;\\n    }\\n}\\n\\ntemplate <typename Func, typename ...Args>\\nvoid debugger_w_printer17(Func&& f, Args&&... args) {\\n    if constexpr (sizeof...(Args) != 0) {\\n        printer17(args...);\\n    }\\n    f(forward<Args>(args)...);\\n}\\n\")), mdx(\"p\", null, \"But we can go further as \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.cppreference.com/w/cpp/language/fold\"\n  }), \"fold expressions\"), \" were added to the C++17! Trying them out:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename Func, typename ...Args>\\nvoid debugger17(Func&& f, Args&&... args) {\\n    if constexpr (sizeof...(Args) != 0) {\\n        ((cout << args << \\\" \\\"), ...);\\n    }\\n    f(forward<Args>(args)...);\\n}\\n\")), mdx(\"p\", null, \"We can write expressions which are using variadic templates! Let\\u2019s join some items (the code is not the best, but just to demonstrate the idea:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename ...Args>\\nstring join(Args&&... args) {\\n    stringstream s;\\n    ((s << args << \\\",\\\"), ...);\\n    string result = s.str();\\n    result.pop_back();\\n    return result;\\n}\\n\\ncout << join(\\\"hello\\\") << endl;\\ncout << join(12, \\\"hello\\\", -45.0, \\\"world\\\") << endl;\\n\")), mdx(\"p\", null, \"Or let\\u2019s add all the arguments to a vector:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"template <typename T, typename... Args>\\nvoid push_all(vector<T>& v, Args&&... args) {\\n    (v.push_back(args), ...);\\n}\\n\\nvector<int> v;\\npush_all(v, 10, 20, -100, 15);\\n\")), mdx(\"p\", null, \"For sure such functions have limited application. But anyway, this looks quite cool and it\\u2019s useful to remember about that feature, so when the time comes you\\u2019ll be ready to use it.\"), mdx(\"p\", null, \"As usual, you can find all the code from the post on \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/artsiukhou/blog_examples/tree/main/variadic-templates-and-fold-expressions\"\n  }), \"GitHub\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/cpp-fold-expressions/","title":"Modern C++: Variadic Templates and Fold Expressions","tags":["C++","templates"],"keywords":[],"date":"May 12, 2021","image":null,"imageAlt":null,"socialImage":null},"previous":{"__typename":"MdxBlogPost","id":"829f6294-9932-585c-be65-99b574303910","excerpt":"Today I want to share some quite random thoughts about  complexity  and why it matters (or not?) with a real-life example I've faced at oneâ€¦","slug":"/complexity-matters/","title":"Complexity Matters?","date":"May 06, 2021"},"next":null},"pageContext":{"id":"bfc4e3ab-a9f1-52e5-86de-a535f72053d8","previousId":"829f6294-9932-585c-be65-99b574303910"}},"staticQueryHashes":["416447326","4198970465","764694655"]}