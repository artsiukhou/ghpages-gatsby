---
title: "Refactoring with Modern(-ish) C++: Method Detection"
date: 2021-04-10
tags: [C++, refactoring, templates]
---


You know that feeling when you've just read about some feature or tool and then you're looking for a chance to use it?
I always wanted to try out some _Modern C++_ meta-template-magic items, and finally, I found a real use case for some
of them in one of the projects I'm working on. Well, sometimes one waits for too long, so worth saying that everything below
is suitable for C++17 (which I do consider _Modern C++_), but in C++20 there are easier ways of achieving the same result.

_All the code from this post can be found on [GitHub](https://github.com/artsiukhou/blog_examples/tree/main/cpp-method-detection)._

I'm refactoring a code in a file that is an entry point to our service.
It contains a lot (really, more than 80) autogenerated signatures of methods that are processing different requests
and there are plenty of common items that are copy-pasted between these methods.
For example, each response type has `.status()` method to access field of type `Status`:

```cpp
class Status {
public:
	string& result() { return _result; }
	string& message() { return _message; }
private:
	string _result;
	string _message;
};

class AnyResponse {
public:
	Status& status() { return _status; }
private:
	Status _status;
};
```

So every request processing function looks like this:

```cpp
RespA entrypointToRequestA(const ReqA& reqA) {
    RespA respA;
    respA.status().result() = "SUCCESS";
    respA.status().message() = "SUCCESS";
    try {
        processReqA(reqA, respA);
	} catch (const std::exception& ex) {
        respA.status().result() = "FAIL";
        respA.status().message() = ex.what();
	}
    return respA;
}
```

I want *any* method to be as simple as:

```cpp
AnyResp entrypointToAnyRequest(const AnyReq& anyReq) {
    return genericProcessor<AnyReq, AnyResp>(anyReq, processAnyReq);
}
```

where `genericProcessor<ReqType, RespType>()` is the following:

```cpp
template <typename Req, typename Resp, typename Processor>
Resp genericProcessor(const Req& req, Processor&& processorFunc) {
    Resp resp;
    resp.status().result() = "SUCCESS";
    resp.status().message() = "SUCCESS";
    try {
        processorFunc(req, resp);
    } catch (const std::exception& ex) {
        resp.status().result() = "FAIL";
        resp.status().message() = ex.what();
    }
    return resp;
}
```

Why? Well, it's 1 line of code instead of 10 (and we have 80 more places like this, remember? reduce [code entropy](https://en.wikipedia.org/wiki/Software_entropy)!).
If it's not enough: I can also modify just 1 method instead of 80 when I want to add, for example, some logs for each of the incoming requests;
or put something different to `.result()` on different exception types; or collect common for each request metrics like `processingTime`. And so on, and so on.

But that's simple, the code from above is already doing it! Uh, ok, I lied. For the reason unknown, some of the responses are just of type `Status`.
"Historical reasons", you know. So code there is:

```cpp
Status entrypointToRequestB(const ReqB& reqB) {
    Status status;
    status.result() = "SUCCESS";
    status.message() = "SUCCESS";
    try {
        processReqB(reqB, status);
    } catch (const std::exception& ex) {
        status.result() = "FAIL";
        status.message() = ex.what();
    }
    return status;
}
```

Ok, easy-peasy, let's introduce the following `setStatus()` function:

```cpp
void setStatus(Status& status, const string_view result, const string_view message) {
    status.result() = result;
    status.message() = message;
}
```

And a templated version of it for any other type, which will even reuse the non-templated:

```cpp
template <typename T>
void setStatus(T& resp, const string_view result, const string_view message) {
    setStatus(resp.status(), result, message);
}
```

Thanks to [function overloading](https://en.cppreference.com/w/cpp/language/overload_resolution), this will work! So our `genericProcessor()` now looks like:

```cpp
template <typename Req, typename Resp, typename Processor>
Resp genericProcessor(const Req& req, Processor&& processorFunc) {
    Resp resp;
    setStatus(resp, "SUCCESS", "SUCCESS");
    try {
        processorFunc(req, resp);
    } catch (const std::exception& ex) {
        setStatus(resp, "FAIL", ex.what());
    }
    return resp;
}
```

Nice! git add, git commit, git push! Wait... Ok, that's not all.
For another set of historical reasons some of the responses don't have anything like `.status()` method at all, they are just responses:

```cpp
RespC entrypointToRequestC(const ReqC& reqC) {
    RespC respC;
    processReqC(reqC, respC);
    return respC;
}
```

So, we can't use the `genericProcessor()` as `RespC` class doesn't have `.status()` method required in the `setStatus()` helper.
But we still want to call it! We want all of our requests to be welcomed equally, have logs and metrics we will define in `genericProcessor()`.
So, what if we will teach templated `setStatus()` to know if the type has `.status()` method, and if it's not then it will be no-op?
Here _Modern C++_ comes in handy!

How can we do this? To be honest, I don't want to go too deep into details and rewrite many good StackOverflow responses and articles from the web because
I'm a) lazy b) lazy (choose your option). I'll be focusing on the big picture and will provide links where you can learn more about how _exactly_ this works.

To start with, we're implementing a helper struct that helps us to detect if some type `T` has `.status()` method
(thanks, [StackOverflow](https://stackoverflow.com/questions/257288/templated-check-for-the-existence-of-a-class-member-function)).

```cpp
template <typename T, typename = std::void_t<>>
struct hasStatus: std::false_type {
};

template <typename T>
struct hasStatus<T, std::void_t<decltype(&T::status)>>: std::true_type {
};
```

The first struct is a templated struct to which any type will be resolved to and it indicates "no-status" types.
The second struct is a [partial specialization](https://en.cppreference.com/w/cpp/language/partial_specialization) of the first struct for types that have `T::status` method.
The main feature here is that if `T` doesn't have this method, it's not an error, thanks to [SFINAE](https://en.cppreference.com/w/cpp/language/sfinae)!
Both `std::false_type` and `std::true_type` structs provide a field `constexpr static bool value` by which we can test the type.

Ok, so now we can modify our `.setStatus()`!

```cpp
template <typename T>
void setStatus(T& resp, const string_view code, const string_view message) {
    if constexpr (hasStatus<T>::value) {
        setStatus(resp.status(), code, message);
    } else {
        /* no-op */
    }
}
```

It compiles, it works on simple structures I'm using for tests.
With a great sense of joy, I copy-pasted our helpers to a real codebase... Added some tests... Ran them... And they... FAILED.

What? How? Why? But it works on tests structs!? And there is no compile error, no warnings, it just produces not the result I want.
Well, requests with just `Status` as response work well. At least something. Requests with no `.status()` method in response work as well.
2 out of 3 already. So the issue is only with requests that have responses with `.status()`.
Looking closer at the real responses and comparing them to the test structs I noticed that each response with `.status()` method actually has 2 such methods:

```cpp
class RealResponse {
public:
    Status& status() { return _status; }
    const Status& status() const { return _status; }
private:
    Status _status;
};
```

Ok, adding the const method to our test struct. And indeed, `hasStatus` doesn't work any more! But why?
Let's have a closer look at the `hasStatus` definition:
```cpp
template <typename T>
struct hasStatus<T, std::void_t<decltype(&T::status)>>: std::true_type {};
```

It takes a return type of `&T::status`. If there is no `.status()` it just skips this definition because of _SFINAE_.
But if there are 2 different `.status()` methods it *doesn't know* which type to take, so it skips it as well!
So for any type with 2 `.status()` methods, this will never work! How this can be fixed?
Instead of checking the method existence on a type, we can instead invoke it on an object of this type by doing `T().status()`, or better `std::declval<T>().status()`!

```cpp
template <typename T>
struct hasStatus<T, std::void_t<decltype(std::declval<T>()::status())>>: std::true_type {};
```

Note that no real invocation happening here, this construction is kind of saying
_"imagine that we have an object of type `T` and we invoke `.status()` and we get the resulting type"_.
And we don't care about the resulting type itself, with `void_t<>` it will be voided anyway.
What we care about is _the whole construction_ to be _valid_, so the specialization will be selected.

That's all, folks!